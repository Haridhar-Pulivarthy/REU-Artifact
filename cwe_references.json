{
    "90" : "Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection') vulnerability: The code constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended query.",
    "114": "Process Control vulnerability: executing commands or loading libraries from an untrusted source or in an untrusted environment can cause an application to execute malicious commands (and payloads) on behalf of an attacker.",
    "121": "Stack-based Buffer Overflow vulnerability: a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).",
    "122": "Heap-based Buffer Overflow vulnerability: a condition where the buffer being overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "123": "Write-What-Where vulnerability: any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.",
    "124": "Buffer Underwrite ('Buffer Underflow') vulnerability: a condition where the code writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
    "125": "Out of Bounds Read vulnerability: a condition where the code reads data past the end, or before the beginning, of the intended buffer.",
    "126": "Buffer Over-read vulnerability: a condition where the code reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
    "127": "Buffer Under-read vulnerability: a condition where the code reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.",
    "134": "Use of Externally-Controlled Format String vulnerability: a condition where the code uses a function that accepts a format string as an argument, but the format string originates from an external source.",
    "176": "Improper Handling of Unicode Encoding vulnerability: a condition where the code does not properly handle when an input contains Unicode encoding.",
    "190": "Integer Overflow or Wraparound vulnerability: a condition where the code performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value.",
    "191": "Integer Underflow (Wrap or Wraparound) vulnerability: a condition where the code subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
    "194": "Unexpected Sign Extension vulnerability: the code performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.",
    "195": "Signed to Unsigned Conversion Error vulnerability: the code uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.",
    "196": "Unsigned to Signed Conversion Error vulnerability: the code uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value if the value of the unsigned primitive can not be represented using a signed primitive.",
    "197": "Numeric Truncation Error vulnerability: truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.",
    "226": "Sensitive Information in Resource Not Removed Before Reuse vulnerability: the code releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear the information contained in the resource before the code makes the resource available for reuse by other entities.",
    "242": "Use of Inherently Dangerous Function vulnerability: the code calls a function that can never be guaranteed to work safely.",
    "244": "Improper Clearing of Heap Memory Before Release (\"Heap Inspection\") vulnerability: using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.",
    "252": "Unchecked Return Value vulnerability: the code does not check the return value from a method or function, which can prevent it from detecting unexpected states or conditions.",
    "253": "Incorrect Check of Function Return Value vulnerability: the code incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.",
    "256": "Plaintext Storage of a Password vulnerability: storing a password in plaintext may result in a system compromise.",
    "259": "Use of Hard-coded Password vulnerability: the code contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.",
    "272": "Least Privilege Violation vulnerability: the elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed.",
    "273": "Improper Check for Dropped Privileges vulnerability: the code attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.",
    "284": "Improper Access Control vulnerability: the code does not restrict or incorrectly restricts access to a resource from an unauthorized actor.",
    "321": "Use of Hard-coded Cryptographic Key vulnerability: the use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.",
    "325": "Missing Cryptographic Step vulnerability: the code does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by the algorithm.",
    "327": "Use of a Broken or Risky Cryptographic Algorithm vulnerability: the code uses a broken or risky cryptographic algorithm or protocol.",
    "338": "Use of a Cryptographically Weak Pseudo-Random Number Generator (PRNG) vulnerability: the code uses a Pseudo-Random Number Generator (PRNG) in a security context, but the PRNG's algorithm is not cryptographically strong.",
    "364": "Signal Handler Race Condition vulnerability: the code uses a signal handler that introduces a race condition.",
    "366": "Race Condition within a Threat vulnerability: tf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
    "367": "Time-of-check Time-of-use (TOCTOU) Race Condition vulnerability: the code checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check.",
    "369": "Divide By Zero vulnerability: the code divides a value by zero.",
    "390": "Detection of Error Condition without Action vulnerability: the code detects a specific error, but takes no actions to handle the error.",
    "391": "Unchecked Error Condition vulnerability: ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.",
    "400": "Uncontrolled Resource Consumption vulnerability: the code does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "401": "Missing Release of Memory after Effective Lifetime vulnerability: the code does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
    "404": "Improper Resource Shutdown or Release vulnerability: the code does not release or incorrectly releases a resource before it is made available for re-use.",
    "415": "Double Free vulnerability: the code calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
    "416": "Use After Free vulnerability: a condition that occurs when memory is referenced after it has been freed, causing the program to crash, use unexpected values, or execute code.",
    "426": "Untrusted Search Path vulnerability: the code searches for critical resources using an externally-supplied search path that can point to resources that are not under the code's direct control.",
    "427": "Uncontrolled Search Path Element vulnerability: the code uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.",
    "457": "Use of an Uninitialized Variable vulnerability: a condition where the code uses a variable that has not been initialized, leading to unpredictable or unintended results.",
    "459": "Incomplete Cleanup vulnerability: the code does not properly 'clean up' and remove temporary or supporting resources after they have been used.",
    "464": "Addition of Data Structure Sentinel vulnerability: the accidental addition of a data-structure sentinel can cause serious programming logic problems.",
    "467": "Use of a sizeof() on a Pointer Type vulnerability: The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.",
    "468": "Incorrect Pointer Scaling vulnerability: one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.",
    "469": "Use of Pointer Subtraction to Determine Size vulnerability: the code subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",
    "475": "Undefined Behavior for Input to API vulnerability: the behavior of this function is undefined unless its control paramter is set to a specific value.",
    "476": "NULL Pointer Dereference vulnerability: a condition that occurs when the code dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
    "479": "Signal Handler Use of a Non-reentrant Function vulnerability: the code defines a signal handler that calls a non-reentrant function.",
    "480": "Use of Incorrect Operator vulnerability: the code accidentally uses the wrong operator, which changes the logic in security-relevant ways.",
    "481": "Assigning instead of Comparing vulnerability: the code uses an operator for assignment when the intention was to perform a comparison.",
    "482": "Comparing instead of Assigning vulnerability: the code uses an operator for comparison when the intention was to perform an assignment.",
    "483": "Incorrect Block Delimination vulnerability: the code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.",
    "484": "Omitted Break Statement in Switch vulnerability: the code omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute.",
    "506": "Embedded Malicious Code vulnerability: the product contains code that appears to be malicious in nature.",
    "511": "Logic/Time Bomb vulnerability: the product contains code that is designed to disrupt the legitimate operation of the product or its environment when a certain time passes or when a certain logical condition is met.",
    "526": "Cleartext Storage of Sensitive Information in an Environment Variable vulnerability: the code uses an environment variable to store unencrypted sensitive information.",
    "535": "Exposure of Information Through Shell Error Message vulnerability: a command shell error message indicates that there exists an unhandled exception in the code; an attacker may leverage the conditions that cause these errors to gain unauthorized access to the system.",
    "561": "Dead Code vulnerability: the product contains dead code, which can never be executed.",
    "562": "Return of Stack Variable Address vulnerability: a function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.",
    "563": "Assignment to Variable without Use vulnerability: the variable's value is assigned but never used, making it a dead store.",
    "570": "Expression is Always False vulnerability: the code contains an expression that will always evaluate to false.",
    "571": "Expression is Always True vulnerability: the code contains an expression that will always evaluate to true.",
    "587": "Assignment of a Fixed Address to a Pointer vulnerability: the code sets a pointer to a specific address other than NULL or 0.",
    "588": "Attempt to Access Child of a Non-structure Pointer vulnerability: casting a non-structure type to a structure type and accessing a field can lead to a memory access error or data corruption.",
    "590": "Free of Memory not on the Heap vulnerability: the code calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().",
    "591": "Sensitive Data Storage in Improperly Locked Memory vulnerability: the code stores sensitive data in memory that is not locked or incorrectly locked, which might cause the memory to be written to swap files on disk by the virtual memory manager.",
    "606": "Unchecked Input for Loop Condition vulnerability: the code does not properly check inputs that are used for loop conditions, potentially leading to excessive looping.",
    "617": "Reachable Assertion vulnerability: the code contains an assert() or similar statement that can be triggered by an attacker, which leads to app exit or other behavior that is more severe than necessary.",
    "620": "Unverified Password Change vulnerability: when setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.",
    "665": "Improper Initialization vulnerability: the code does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.",
    "667": "Improper Locking vulnerability: the code does not properly acquire or release a lock on a resource, leading to unexpected resource state changes or behaviors.",
    "674": "Uncontrolled Recursion vulnerability: the code does not properly control the amount of recursion that takes place, consuming excessive resources, such as allocated memory or the program stack.",
    "675": "Multiple Operations on Resource in Single-Operation Context vulnerability: the code performs the same operation on a resource two or more times, when this operation should only be applied once.",
    "680": "Integer Overflow to Buffer Overflow vulnerability: the code performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",
    "681": "Incorrect Conversion between Numeric Types vulnerability: when converting from one data type to another, data can be omitted or translated in a way that produces unexpected values.",
    "685": "Function Call With Incorrect Number of Arguments vulnerability: the code calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.",
    "690": "Unchecked Return Value to NULL Pointer Dereference vulnerability: the code does not check for an error after calling a function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference.",
    "758": "Reliance on Undefined, Unspecified, or Implementation-Defined Behavior vulnerability: the product uses an API function, data structure, or other entity in a way that relies on properties that are not always guaranteed to hold for that entity.",
    "761": "Free of Pointer not at Start of Buffer vulnerability: the code calls free() on a pointer to a memory resource that was allocated on the heap, but the pointer is not at the start of the buffer.",
    "773": "Missing Reference to Active File Descriptor or Handle vulnerability: the code does not properly maintain references to a file descriptor or handle, which prevents that file descriptor/handle from being reclaimed.",
    "775": "Missing Release of File Descriptor or Handle after Effective Lifetime vulnerability: the code does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.",
    "787": "Out of Bounds Write vulnerability: a condition where the code writes data past the end, or before the beginning, of the intended buffer.",
    "832": "Use of Out-of-range Pointer Offset vulnerability: the code performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
    "835": "Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability: the code contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "843": "Access of Resource Using Incompatible Type ('Type Confusion') vulnerability: the product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type."
}